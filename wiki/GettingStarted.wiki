#labels Featured
Consider a simple java bean:
{{{
public class Person
{
    private String name;
    private String description;
    private int age;
    private Date birthDate;
    private boolean gender;
// ... getters and setters
}
}}}
You can create custom editors for its instances and it takes few lines of code.

=Default Configuration=
This simple code will add a JPanel with GridBagLayout to a frame:
{{{        
JFrame myFrame = new JFrame();
// make proper initialization
Form<Person> form = FormBuilder.map( Person.class ).buildForm();
myFrame.add( form.asComponent() );
}}}
Each row represents a property and contains a JLabel and a specific editor component:

[http://swing-formbuilder.googlecode.com/svn/trunk/doc/default.png]

To display a given instance, simply write:
{{{
Person person = new Person();
person.setName( "john smith" );
// ... further initialization
form.setValue( person );
}}}
Note, that `person` will not be modified as you enter new values in a form. Instead, a copy will be returned. (_Different strategies of changing instances age coming up soon_). So
{{{
Person changed = form.getValue();
assert person != changed;
}}}
=Mapping by sample=
What if you need a custom layout of the editor components? Pass an instance of a `BeanMapper` into builder.

For example, `SampleBeanMapper` guides a panel creation using a dynamic proxy of a bean. Since a panel is created _before_ the value is set, an empty bean stub is being passed into `mapBean` method. Note that `beanSample` is a dynamic proxy, created by CGLIB.
{{{
Form<Person> form = FormBuilder.map( Person.class ).with( new SampleBeanMapper<Person>()
        {
            @Override
            protected JComponent mapBean( final Person beanSample )
            {
                final Box box = Box.createVerticalBox();
                box.add( label( beanSample.getName() ) );
                box.add( editor( beanSample.getName() ) );
                return box;
            }
        } ).buildForm();
}}}
If you don't want to include CGLIB dependency, use `PropertyNameBeanMapper` instead. It founds suitable components by property names. This is less magical, but more error-prone, since property names can be changed or misspelled.
{{{
Form<Person> form = FormBuilder.map( Person.class ).with( new PropertyNameBeanMapper<Person>()
        {
            @Override
            public JComponent mapBean()
            {
                final Box box = Box.createVerticalBox();
                box.add( label( "name" ) );
                box.add( editor( "name" ) );
                return panel;
            }
        } ).buildForm();
}}}

=Custom type mapping=
Most common property types are mapped by default to specific components using `TypeMapper`. If you need to change the default type mapping, implement your own mapper (see below) and pass it into a builder.

For instance, you want to represent each `String` with `JTextArea` instead of `JTextField`:
{{{
Form<Person> form = FormBuilder.map( Person.class ).use( new StringToTextAreaMapper() ).buildForm();
}}}

=Custom property mapping=
To use custom mapping only for specific properties, write the following:
{{{
Form<Person> form = FormBuilder.map( Person.class )
                .useForProperty( "description", new StringToTextAreaMapper() ).buildForm();
}}}
or in a more sophisticated, but type-safe way (CGLIB proxy-magic again):
{{{
Form<Person> form = FormBuilder.map( Person.class ).useForGetters( new GetterMapper<Person>()
        {
            @Override
            protected void mapGetters( final Person beanSample )
            {
                mapGetter( beanSample.getDescription(), new StringToTextAreaMapper() );
            }
        } ).buildForm();
}}}

=Disabling the validation=
{{{
Form<Person> form = FormBuilder.map( Person.class ).doValidation( false ).buildForm();
}}}

=Writing a custom mapper=
{{{
class DateToDateChooserMapper
        implements
        TypeMapper<JDateChooser, Date>
    {
        @Override
        public Class<Date> getValueClass()
        {
            return Date.class;
        }

        @Override
        public JDateChooser createEditorComponent()
        {
            return new JDateChooser();
        }

        @Override
        public Date getValue( final JDateChooser editorComponent )
        {
            return editorComponent.getDate();
        }

        @Override
        public void setValue( final JDateChooser editorComponent, final Date value )
        {
            editorComponent.setDate( value );
        }

        @Override
        public void bindChangeListener( final JDateChooser editorComponent,
            final ValueChangeListener<Date> changeListener )
        {
            editorComponent.getDateEditor().addPropertyChangeListener( "date", new PropertyChangeListener()
            {
                @Override
                public void propertyChange( final PropertyChangeEvent evt )
                {
                    changeListener.onChange();
                }
            } );
        }

        @Override
        public ValidationMarker getValidationMarker()
        {
            return BackgroundMarker.INSTANCE;
        }
    }
}}}